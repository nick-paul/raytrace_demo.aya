import canvas
import  threading
require color { color }

require ".vecutils" *
require ".material" { material lambertian metal dielectric }
require ".hittable" { sphere hittable_list }
require ".camera"   { camera }


:{
    .# Full-res
    .#140  :samples_per_pixel;
    .#50   :diffuse_depth;
    .#400  :image_width;
    .#2  :canvas_scale;

    .# Med res
    .# 80  :samples_per_pixel;
    .# 40   :diffuse_depth;
    .# 200  :image_width;
    .# 4 :canvas_scale;

    .# Low res
    40 :samples_per_pixel;
    20 :diffuse_depth;
    70 :image_width;
    8  :canvas_scale;

    3 2 /:aspect_ratio;
    image_width aspect_ratio / .\ :image_height;
} :render_config;


{r::ray world::hittable_list depth::num : 
    unit_direction n t rec should_scatter
    attenuation scattered double_max^ unit_vector^,
    depth 0 :< {
       .# If we've exceeded the ray bounce limit, no more
       .# light is gathered
        [ 0 0 0 ]
    } {
        r 0.001 double_max world.hit :rec;

        rec 0 = {
            .# No hit
            r.direction unit_vector :unit_direction;
            unit_direction.y 1 + 0.5 * :t;
            ([1 1 1] 1 t - *) ([0.5 0.7 1.0] t *) +
        } {
            .# Hit!
            .#rec.normal [1 1 1] + 0.5 *

            .# rec.p rec.normal + random_unit_vector + :target;
            .# ((rec.p, target rec.p -) ray!, world, depth 1 -) ray_color 0.5 *

            (r, rec) rec.mat_ptr.scatter :should_scatter; :attenuation; :scattered;
            should_scatter {
                (scattered, world, depth 1 -) ray_color attenuation *
            } {
                [0 0 0]
            } .?
        } .?
    } .?

    .# break_if_inf
}:ray_color; .# -> [r g b]

.#
.# SCENE
.#

{:
    ground_material([0.5 0.5 0.5] lambertian!)
    world
    vlen^
    sphere^
    lambertian^
    dielectric^
    metal^
    hittable_list^
    ,

    [] :world;

    .# Ground
    ([0 -1000 0], 1000, ground_material) sphere! world.append;

    .# Little Spheres
    1 :little_spheres_m;

    [little_spheres_m -1* little_spheres_m] R :# {a,
        [little_spheres_m -1 * little_spheres_m] R :# {b :
                choose_mat center sphere_material,

            0.5 :little_sphere_rad_base;
            little_sphere_rad_base .Q 0.5- 0.2 * + :little_sphere_rad;

            [(5 a * 2+, 
              little_sphere_rad,
              5 b * 2+)] :center;

            center [4 little_sphere_rad 0] - vlen 0.9 > {
                {
                    (choose_mat 0.8 <) {
                        .# Diffuse
                        (center, little_sphere_rad, [.Q .Q .Q] lambertian!) sphere! world.append;
                    } (choose_mat 0.95 <) {
                        .# Metal
                        (   center,
                            little_sphere_rad,
                            [{.Q 2 / 0.5 +}3%]  .# albedo: rng 0.5-1 x3
                            .Q 2 /              .# fuzz:   rng 0-0.5
                            metal!
                        ) sphere! world.append;
                    } {
                        .# Glass
                        (center, little_sphere_rad, 1.5 dielectric!) sphere! world.append;
                    }
                } :?
            } ?
        };
    };


    .# Big Spheres
    ([ 0 1 0], 1, 1.5             dielectric!) sphere! world.append;
    ([-4 1 0], 1, [0.4 0.2 0.1]   lambertian!) sphere! world.append;
    ([ 4 1 0], 1, [0.7 0.6 0.5] 0 metal!     ) sphere! world.append;

    world hittable_list!

}:make_final_world;



{:
    lookfrom([12 2 4])
    lookat([0 0 0])
    vup([0 1 0])
    aperture(0.1)
    aspect_ratio(render_config.aspect_ratio)
    dist_to_focus
    vlen^
    camera^
    ,

    lookfrom lookat - vlen :dist_to_focus;
    (lookfrom, lookat, vup, 20, aspect_ratio, aperture, dist_to_focus) camera!
}:final_cam;



.#
.# RENDER
.#




{image_x image_y col n_samples cvs : scale clamp^ color^,
    1 n_samples / :scale;
    col scale * .^  #{0 1 clamp} :col;

    255.999 col * .\ :col;

    col ~ color! cvs.set_color
    image_y 1- cvs.height image_x - 1- cvs.point
}:write_color;



.# Render

{line_number cam world : ray_color^ render_config^,
    line_number

    .#line_number 2 :% 0 = {"Scanlines remaining: $line_number" :P} ?
    [render_config.image_width, {col_number : u v r pixel_color,
        [0 0 0] :pixel_color;
        [render_config.samples_per_pixel, 
            col_number  .Q + render_config.image_width 1 - / :u;
            line_number .Q + render_config.image_height 1 - / :v;

            u v cam.get_ray :r;

            r world render_config.diffuse_depth ray_color pixel_color + :pixel_color;
        ];
        [col_number pixel_color]
    }]
}:render_scanline;





{:
    render_config^
    make_final_world^
    final_cam^
    render_scanline^
    threading^
    write_color^
    canvas^
    ,

    M$ local :start_time;

    7 local :n_threads;

    "Image size (WxH): $(render_config.image_width) x $(render_config.image_height)" :P

    :{
        render_config.image_height :height;
        render_config.image_width :width;
        render_config.canvas_scale :scale;
        1 :show;
    } canvas.canvas! local :cvs;

    make_final_world local :world;
    final_cam local :cam;


    [render_config.image_height, {line_number,
        { :line_number(line_number 1 -) render_scanline^ cam^ world^, 
            (line_number, cam, world) render_scanline
        } 
    }] local :tasks;

    n_threads threading.pool! local :workers;


    {[line_number col_and_pixels] : cvs^ render_config^ write_color^, 
        col_and_pixels :# {[col_number pixel_color],
            line_number col_number pixel_color render_config.samples_per_pixel cvs write_color
        }
        cvs.show
    } local:draw_result;

    tasks draw_result.` workers.exec

    M$ local :end_time;

    end_time start_time - 1000 / local :exec_time;

    "Render finished in $(exec_time)s ($(n_threads) threads)" :P

    "image.png" cvs.save

    "Press enter to continue..." :P
    :R;
}:__run__;


main {:__run__^,
    __run__
}
